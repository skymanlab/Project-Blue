package com.skyman.billiarddata.factivity.statistics;import android.os.Bundle;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import androidx.annotation.NonNull;import androidx.annotation.Nullable;import androidx.fragment.app.Fragment;import com.applandeo.materialcalendarview.CalendarView;import com.applandeo.materialcalendarview.EventDay;import com.applandeo.materialcalendarview.listeners.OnDayClickListener;import com.skyman.billiarddata.R;import com.skyman.billiarddata.developer.DeveloperManager;import com.skyman.billiarddata.dialog.BilliardInfo;import com.skyman.billiarddata.management.billiard.data.BilliardData;import com.skyman.billiarddata.management.calendar.SameDateChecker;import com.skyman.billiarddata.management.calendar.SameDateCheckerMake;import com.skyman.billiarddata.management.calendar.Utils.DrawableUtils;import com.skyman.billiarddata.management.projectblue.data.ProjectBlueDataFormatter;import com.skyman.billiarddata.management.user.data.UserData;import java.util.ArrayList;import java.util.Calendar;import java.util.StringTokenizer;/** * A simple {@link Fragment} subclass. * Use the {@link CalendarFragment#newInstance} factory method to * create an instance of this fragment. */public class CalendarFragment extends Fragment {    // TODO: Rename parameter arguments, choose names that match    // the fragment initialization parameters, e.g. ARG_ITEM_NUMBER    private static final String ARG_PARAM1 = "param1";    private static final String ARG_PARAM2 = "param2";    // constant    private final String CLASS_NAME_LOG = "";    private final String DATE_DELIMITER = "년월일 ";    // instance variable    private CalendarView calendarView;    // instance variable    private UserData userData;    private ArrayList<BilliardData> billiardDataArrayList;    private SameDateChecker sameDateChecker;    // TODO: Rename and change types of parameters    private String mParam1;    private String mParam2;    // constructor    public CalendarFragment(UserData userData, ArrayList<BilliardData> billiardDataArrayList, SameDateChecker sameDateChecker) {        this.userData = userData;        this.billiardDataArrayList = billiardDataArrayList;        this.sameDateChecker = sameDateChecker;    }    // constructor    public CalendarFragment() {        // Required empty public constructor    }    /**     * Use this factory method to create a new instance of     * this fragment using the provided parameters.     *     * @param param1 Parameter 1.     * @param param2 Parameter 2.     * @return A new instance of fragment CalendarFragment.     */    // TODO: Rename and change types and number of parameters    public static CalendarFragment newInstance(String param1, String param2) {        CalendarFragment fragment = new CalendarFragment();        Bundle args = new Bundle();        args.putString(ARG_PARAM1, param1);        args.putString(ARG_PARAM2, param2);        fragment.setArguments(args);        return fragment;    }    @Override    public void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        if (getArguments() != null) {            mParam1 = getArguments().getString(ARG_PARAM1);            mParam2 = getArguments().getString(ARG_PARAM2);        }    }    @Override    public View onCreateView(LayoutInflater inflater, ViewGroup container,                             Bundle savedInstanceState) {        // Inflate the layout for this fragment        return inflater.inflate(R.layout.fragment_calendar, container, false);    }    @Override    public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {        super.onViewCreated(view, savedInstanceState);        DeveloperManager.displayLog("[F]_CalendarFragment", "[onViewCreated] userData 확인 : " + this.userData);        DeveloperManager.displayToUserData("[F]_CalendarFragment", this.userData);        DeveloperManager.displayLog("[F]_CalendarFragment", "[onViewCreated] billiardDataArrayList 확인 : " + this.billiardDataArrayList);        DeveloperManager.displayToBilliardData("[F]_CalendarFragment", this.billiardDataArrayList);        // [iv/C]CalendarView : calendarView mapping        this.calendarView = (CalendarView) view.findViewById(R.id.f_calendar_cv_game_record);        // [check 1] : userData 와 billiardDataArrayList 가 모두 있다. 즉, EventDay 를 구할 method 를 실행할 준비가 되었다.        if (checkWhetherFindEventsDay()) {            // [check 2] : dateChecker 가 만들어 졌다.            if (this.sameDateChecker != null) {                // [lv/C]ArrayList<EventDay> : dateChecker 와 billiardDataArrayList 를 통해서 EventDay 를 설정하고, 이 EventDay 가 담긴 ArrayList 를 받아온다.                ArrayList<EventDay> eventDayList = makeEventDayListWithSameDateCheckerAndAllBilliardData(this.sameDateChecker, this.billiardDataArrayList);                // [check 3] : eventDayList 에 담긴 내용이 있다.                if (eventDayList.size() != 0) {                    // [iv/C]CalendarView : 위에서 만들어진 eventDayList 를 calendarView 에 표시하기                    this.calendarView.setEvents(eventDayList);                } else {                    DeveloperManager.displayLog("[F]_CalendarFragment", "[onViewCreated] dateChecker 와 billiardDataArrayList 로 EventDay 가 담긴 ArrayList 가 만들어지지 않았습니다.");                } // [check 3]            } else {                DeveloperManager.displayLog("[F]_CalendarFragment", "[onViewCreated] userData 와 billiardDataArrayList 로 SameDateChecker 가 만들어지지 않았습니다.");            } // [check 2]        } else {            DeveloperManager.displayLog("[F]_CalendarFragment", "[onViewCreated] userData 와 billiardDataArrayList 가 없으므로 달력에 표시할 EventDay 가 없습니다.");        } // [check 1]        // [iv/C]CalendarView : calendarView date click listener        this.calendarView.setOnDayClickListener(new OnDayClickListener() {            @Override            public void onDayClick(EventDay eventDay) {                // [lv/C]String : 클릭 한 날의 eventDay 로 Date 형태의 객체 받아오기                String dateContent = ProjectBlueDataFormatter.getFormatOfDate(eventDay.getCalendar().getTime());                DeveloperManager.displayLog("[F]_CalendarFragment", "[calendarView button] " + dateContent);                // [lv/i]position : 위에서 구한 날짜가 billiardDataArrayList 에서 같은 날짜가 있으면 그 index 를 반환                int position = getPositionOfEqualDate(dateContent);                DeveloperManager.displayLog("[F]_CalendarFragment", "[calendarView button] positon : " + getPositionOfEqualDate(dateContent));                // [check 1] : position 이 있다.                if (position >= 0) {                    // [check 2] : dataChecker 의 getArraySize 가 0 이 아니다.                    if (sameDateChecker.getArraySize() != 0) {                        // [lv/C]BilliardInfo : custom 한 dialog 를 생성하기                        BilliardInfo billiardInfo = new BilliardInfo(getContext(), sameDateChecker, billiardDataArrayList, position);                        // [lv/C]BilliardInfo : dialog 만들고 화면에 출력하기                        billiardInfo.setDialog();                    } else {                    } // [check 2]                } else {                }// [check 1]            }        });    } // End of method [onViewCreated]    /*                                      private method     * =============================================================================================     * =============================================================================================     * */    /**     * [method] date 값을 billiardDataArrayList 의 getDate 값과 비교 하여 같으면 position , 다르면 -1 반환     */    private int getPositionOfEqualDate(String date) {        // [cycle 1] : billiardDataArrayList 의 size 만큼 순환하며 비교        for (int position = 0; position < billiardDataArrayList.size(); position++) {            DeveloperManager.displayLog("[F]_CalendarFragment", "[getPositionOfEqualDate] getDate : " + date + " / getDate : " + billiardDataArrayList.get(position).getDate());            // [check 1] : billiardDate 의 getDate 와 date 가 같은 내용이다.            if (date.equals(billiardDataArrayList.get(position).getDate())) {                DeveloperManager.displayLog("[F]_CalendarFragment", "[getPositionOfEqualDate] getDate 와 date 가 일치하는 곳이 있군요.");                return position;            } else {                continue;            } // [check 1]        } // [cycle 1]        DeveloperManager.displayLog("[F]_CalendarFragment", "[getPositionOfEqualDate] getDate 와 date 가 모두 다릅니다.");        return -1;    } // End of method [getPositionOfEqualDate]    /**     * [method] userData 와 billiardDataArrayList 가 null 이 아닌지를 검사한다.     */    private boolean checkWhetherFindEventsDay() {        // [check 1] : userData 가 있고 billiardDataArrayList 에 데이터가 있습니다.        if ((this.userData != null) && (this.billiardDataArrayList.size() != 0)) {            DeveloperManager.displayLog("[F]_CalendarFragment", "[checkWhetherFindEventsDay] userData, billiardDataArrayList 가 모두 있습니다. EventDay 를 구하는 작업을 해도 됩니다.");            return true;        } else {            DeveloperManager.displayLog("[F]_CalendarFragment", "[checkWhetherFindEventsDay] userData 가 없고, billiardDataArrayList 에 데이터도 없습니다.");            return false;        } // [check 1]    } // End of method [checkWhetherFindEventsDay]    // ================================================================= EventDay List make =========================================================================    /**     * [method] DateChecker 으로 EventDay 를 만들어 ArrayList<EventDay> 로 만들어서 반환한다.     */    private ArrayList<EventDay> makeEventDayListWithSameDateCheckerAndAllBilliardData(SameDateChecker sameDateChecker, ArrayList<BilliardData> billiardDataArrayList) {        // [lv/C]ArrayList<EventDay> : 데이터를 담을 객체 생성        ArrayList<EventDay> eventDayArrayList = new ArrayList<>();        // [cycle 1] : 같은 날짜가 검사되어 있는 sameDateChecker 의 size 만큼        for (int index = 0; index < sameDateChecker.getArraySize(); index++) {            DeveloperManager.displayLog("[F]_CalendarFragment", "[makeEventDayListWithSameDateCheckerAndAllBilliardData] >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>");            // [check 1] : 기준 날짜이다.            if (sameDateChecker.getStandardDateToIndex(index)) {                DeveloperManager.displayLog("[F]_CalendarFragment", "[makeEventDayListWithSameDateCheckerAndAllBilliardData] >> 기준 날짜는 ? >> " + billiardDataArrayList.get(index).getDate() + " >> position : " + index);                // [lv/C]Calendar : billiardData 의 date 로 Calendar 객체 만들기                Calendar calendar = makeCalendarWithDateItems(changeDateToIntArrayType(billiardDataArrayList.get(index).getDate()));                // [method]checkEventDayType : sameDateChecker 의 winCount, lossCount 로 EventDay 의 유형을 구분하여 eventDayList 에 추가하기                // [lv/C]ArrayList<EventDay> : Event Day 의 유형을 구분하여 만들어진 EventDay 를 ArrayList 에 추가한다.                eventDayArrayList.add(makeEventDayToWinAndLoss(sameDateChecker.getWinCountToIndex(index), sameDateChecker.getLossCountToIndex(index), calendar, eventDayArrayList));            } else {                DeveloperManager.displayLog("[F]_CalendarFragment", "[makeEventDayListWithSameDateCheckerAndAllBilliardData] >> 기준 날짜가 아닙니다 >> " + index);            } // [check 1]        } // [cycle 1]        return eventDayArrayList;    } // End of method [makeEventDayListWithSameDateCheckerAndAllBilliardData]    /**     * [method] date 문자열을 StringTokenizer 로 구분한 뒤, 각 문자열을 int 로 parse 한 다음 배열에 담아 반환한다.     *     * @param date 날짜 문자열     * @return 분할 된 날짜가 integer 로 변환되어 담긴 배열     */    private int[] changeDateToIntArrayType(String date) {        // [lv/i]dateTokenList : 매개변수 문자열이 분할되어 integer 로 parsing 된 다음 저장될 변수        int[] dateTokenList = new int[3];        // [lv/C]StringTokenizer : 매개변수 문자열을 '년월일 ' 로 나누기 / DATE_DELIMITER : '년월일 ' / delimiter : 구분자        StringTokenizer tokenizer = new StringTokenizer(date, DATE_DELIMITER);        // [cycle 1] : 구분된 값들이 있을 때까지 해당 값을 배열에 넣기        for (int positon = 0; tokenizer.hasMoreTokens(); positon++) {            // [lv/i]dateTokenList : 분할 된 토큰을 year, month, day 순으로 integer 로 parsing 한 값을 담는다.            dateTokenList[positon] = Integer.parseInt(tokenizer.nextToken());        } // [cycle 1]        return dateTokenList;    } // End of method [changeDateToIntArrayType]    /**     * [method] year, month, day 로 Calendar 객체 만들기     *     * @param dateItem int 타입의 year, month, day 담겨있는 배열     * @return 해당 날짜로 만들어진 Calendar 객체     */    private Calendar makeCalendarWithDateItems(int[] dateItem) {        // [lv/C]Calendar : 객체 선언        Calendar calendar = null;        // [check 1] : dataItem 의 length 가 3 이다.        if (dateItem.length == 3) {            // [lv/C]Calendar : 객체 생성            calendar = Calendar.getInstance();            // [lv/C]Calendar : 매개변수 값으로 날짜 설정하기            calendar.set(dateItem[0], dateItem[1] - 1, dateItem[2]);        } else {            DeveloperManager.displayLog("[F]_CalendarFragment", "[makeCalendarWithDateItems] dateItem 의 length 는 3 이어야 합니다. 왜냐면 year, month, day 만 저장되어있는 array variable 이기 때문입니다.");        }        return calendar;    } // End of method [makeCalendarWithDateItems]    /**     * [method] winCount, lossCount 가 값이 있는지로 EventDay 의 type 을 결정     */    private EventDay makeEventDayToWinAndLoss(int winCount, int lossCount, Calendar calendar, ArrayList<EventDay> eventDayList) {        EventDay eventDay = null;        // [check 1] : WinCount, LossCount 을 구분한다.        if ((winCount > 0) && (lossCount > 0)) {            // 승리, 패배 모두 있다.            DeveloperManager.displayLog("[F]_CalendarFragment", "[makeEventDayToWinAndLoss] >> 기준 날짜로 Blue & Red로 설정합니다. >>");            // [lv/C]ArrayList<EventDay> : calendar 으로 EventDay 생성하여 추가 - Blue & Red            eventDay = new EventDay(calendar, DrawableUtils.getBlueOrRedCircleDrawableWithText(getContext(), "" + winCount + "  " + lossCount));        } else if ((winCount > 0) && (lossCount == 0)) {            // 승리만 있다.            DeveloperManager.displayLog("[F]_CalendarFragment", "[makeEventDayToWinAndLoss] >> 기준 날짜로 Blue 로 설정합니다. >> ");            // List<EventDay> : 위 의 calendar 으로 EventDay 생성하여 추가 - Blue            eventDay = new EventDay(calendar, DrawableUtils.getBlueCircleDrawableWithText(getContext(), "" + winCount));        } else if ((winCount == 0) && (lossCount > 0)) {            // 패배만 있다.            DeveloperManager.displayLog("[F]_CalendarFragment", "[makeEventDayToWinAndLoss] >> 기준 날짜로 Red 로 설정합니다. >>");            // List<EventDay> : 위 의 calendar 으로 EventDay 생성하여 추가 - Blue & Red            eventDay = new EventDay(calendar, DrawableUtils.getRedCircleDrawableWithText(getContext(), "" + lossCount));        } else {            DeveloperManager.displayLog("[F]_CalendarFragment", "[makeEventDayToWinAndLoss] >> 승리도 패배도 없는 날인데요. >>");        } // [check 1]        return eventDay;    } // End of method [makeEventDayToWinAndLoss]}