package com.skyman.billiarddata.factivity.statistics.calendar;import android.app.AlertDialog;import android.content.DialogInterface;import android.os.Bundle;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import androidx.annotation.NonNull;import androidx.annotation.Nullable;import androidx.fragment.app.Fragment;import com.applandeo.materialcalendarview.CalendarView;import com.applandeo.materialcalendarview.EventDay;import com.applandeo.materialcalendarview.listeners.OnDayClickListener;import com.skyman.billiarddata.R;import com.skyman.billiarddata.developer.DeveloperManager;import com.skyman.billiarddata.factivity.statistics.calendar.Utils.DrawableUtils;import com.skyman.billiarddata.management.billiard.data.BilliardData;import com.skyman.billiarddata.management.billiard.database.BilliardDBManager;import com.skyman.billiarddata.management.projectblue.data.ProjectBlueDataFormatter;import com.skyman.billiarddata.management.user.data.UserData;import com.skyman.billiarddata.management.user.database.UserDbManager;import java.util.ArrayList;import java.util.Calendar;import java.util.List;import java.util.StringTokenizer;/** * A simple {@link Fragment} subclass. * Use the {@link CalendarFragment#newInstance} factory method to * create an instance of this fragment. */public class CalendarFragment extends Fragment {    // constant    private final String DATE_DELIMITER = "년월일 ";    // variable : CalendarView    private CalendarView calendarView;    private List<EventDay> eventDayList = new ArrayList<>();    // variable : DbManager    private BilliardDBManager billiardDbManager;    private UserDbManager userDbManager;    private ArrayList<BilliardData> billiardDataArrayList = null;    private UserData userData = null;    // TODO: Rename parameter arguments, choose names that match    // the fragment initialization parameters, e.g. ARG_ITEM_NUMBER    private static final String ARG_PARAM1 = "param1";    private static final String ARG_PARAM2 = "param2";    // TODO: Rename and change types of parameters    private String mParam1;    private String mParam2;    // constructor    public CalendarFragment(UserDbManager userDbManager, BilliardDBManager billiardDBManager) {        this.userDbManager = userDbManager;        this.billiardDbManager = billiardDBManager;    }    // constructor    public CalendarFragment() {        // Required empty public constructor    }    /**     * Use this factory method to create a new instance of     * this fragment using the provided parameters.     *     * @param param1 Parameter 1.     * @param param2 Parameter 2.     * @return A new instance of fragment CalendarFragment.     */    // TODO: Rename and change types and number of parameters    public static CalendarFragment newInstance(String param1, String param2) {        CalendarFragment fragment = new CalendarFragment();        Bundle args = new Bundle();        args.putString(ARG_PARAM1, param1);        args.putString(ARG_PARAM2, param2);        fragment.setArguments(args);        return fragment;    }    @Override    public void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        if (getArguments() != null) {            mParam1 = getArguments().getString(ARG_PARAM1);            mParam2 = getArguments().getString(ARG_PARAM2);        }    }    @Override    public View onCreateView(LayoutInflater inflater, ViewGroup container,                             Bundle savedInstanceState) {        // Inflate the layout for this fragment        return inflater.inflate(R.layout.fragment_calendar, container, false);    }    @Override    public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {        super.onViewCreated(view, savedInstanceState);        // [method]getDateOfUserOrBilliard :        getDataOfUserOrBilliard();        // [iv/C]CalendarView : calendarView mapping        this.calendarView = (CalendarView) view.findViewById(R.id.f_calendar_cv_game_record);        // [iv/C]CalendarView : calendarView date click listener        this.calendarView.setOnDayClickListener(new OnDayClickListener() {            @Override            public void onDayClick(EventDay eventDay) {                // [lv/C]String : 클릭 한 날의 eventDay 로 Date 형태의 객체 받아오기                String dateContent = ProjectBlueDataFormatter.getFormatOfDate(eventDay.getCalendar().getTime());                DeveloperManager.displayLog("[F]_CalendarFragment", "[calendarView button] " + dateContent);                // [check 1] : billiardDataArrayList 에 일치하는 값이 있다.                if (checkDateToBilliardData(dateContent)) {                } else {                    DeveloperManager.displayLog("[F]_CalendarFragment", "[calendarView button] 현재 날짜가 일치하는 데이터가 없습니다.");                } // [check 1]                DeveloperManager.displayLog("[F]_CalendarFragment", "[calendarView button] positon : " + getPositionOfEqualDate(dateContent));                int position = getPositionOfEqualDate(dateContent);                if (position >= 0) {                    showAlertToBilliardData(position);                }                //            }        });        // CalendarView : event setting - 같은 날짜일 때 중복 된 승패를 표현하지 못 함.        DeveloperManager.displayLog("[F]_CalendarFragment", "[calendarView button] ==================================================================================");        setEventDaysOfCheckedDate();        DeveloperManager.displayLog("[F]_CalendarFragment", "[calendarView button] ==================================================================================");    } // End of method [onViewCreated]    /*                                      private method     * =============================================================================================     * =============================================================================================     * */    /**     * [method] 해당 userId 값으로 user, billiard 테이블에서 데이터를 가져오기     *     */    private void getDataOfUserOrBilliard() {        // [iv/C]UserData : 해당 userId 로 user 데이터를 가져온다.        this.userData = this.userDbManager.loadContent(1);        // [iv/C]ArrayList<BilliardData> : 해당 userId 로 모든 billiard 데이터를 가져온다.        this.billiardDataArrayList = billiardDbManager.loadAllContentByUserID(1);    } // End of method [getDataOfUserOrBilliard]    /**     * [method] billiardDataArrayList 를 가지고 각 날짜의 win 과 loss 카운트하여 EventDay 를 만든다.     *     */    private DateChecker setEventDaysOfCheckedDate() {        // DateChecker : 각 date 에 win 과 loss 가 몇 개인지 구분        DateChecker dateChecker = new DateChecker(billiardDataArrayList.size());        dateChecker.initArray();        // cycle 1 : billiardDataArrayList 의 Date 를 가져와 중복 date 를 찾아 체크하고, 그 date 의 win 과 loss 의 수를 구한다.        for (int index = 0; index < billiardDataArrayList.size(); index++) {            // check 1 : checkedDate[index] 의 값이 false 일 때 - 체크 안 된 date            if (!dateChecker.getCheckedDateToIndex(index)) {                DeveloperManager.displayLog("[F]_CalendarFragment", "[setEventDayToCheckedDate] ===============기준인 " + index + " 번째 date : " + billiardDataArrayList.get(index).getDate());                // DateChecker : 위 의 check 1 을 수행 하였으므로 index 번째를 true 로 - checkedDate                dateChecker.setTrueToCheckedDate(index);                // DateChecker : 위 의 check 1 을 수행 하였으므로 index 번째를 true 로 - checkedDate                dateChecker.setTrueToStandardDate(index);                // cycle 2 : [index+1] 인 배열부터 배열 끝 까지 date 가 같은지 비교                for (int nextIndex = index + 1; nextIndex < billiardDataArrayList.size(); nextIndex++) {                    //  check A : nextIndex 번째가 true 가 아닐 때만 비교하기 위해서                    if (!dateChecker.getCheckedDateToIndex(nextIndex)) {                        DeveloperManager.displayLog("[F]_CalendarFragment", "[setEventDayToCheckedDate] 비교대상인 " + nextIndex + " 번째 date : " + billiardDataArrayList.get(nextIndex).getDate());                        // check 2 : index 번째의 date 를 기준으로 nextIndex(index+1 부터 끝까지) 의 date 가 같다.                        if (billiardDataArrayList.get(index).getDate().equals(billiardDataArrayList.get(nextIndex).getDate())) {                            DeveloperManager.displayLog("[F]_CalendarFragment", "[setEventDayToCheckedDate] 비교대상인 " + nextIndex + " 번째 는 같습니다. 이제 승리 패배를 구분하겠습니다.");                            // checkedDate : nextIndex 번째가 같므로 체크한 날짜로 바꾼다.                            dateChecker.setTrueToCheckedDate(nextIndex);                            DeveloperManager.displayLog("[F]_CalendarFragment", "[setEventDayToCheckedDate] 비교대상인 " + nextIndex + " 번째 - userName : " + userData.getName() + " / getWinner : " + billiardDataArrayList.get(nextIndex).getWinner());                            // check 3-1 : nextIndex 번째의 winner 를 통해 승리('W') 인지 패배('L') 인지 구분한 값 받아오기                            char classification = checkWinOrLoss(userData.getName(), billiardDataArrayList.get(nextIndex).getWinner());                            DeveloperManager.displayLog("[F]_CalendarFragment", "[setEventDayToCheckedDate] 비교대상인 " + nextIndex + " 번째의 비교 결과는 " + classification);                            // check 3-2 : classification 값을 통해 winCount[index]+1 할지 lossCount[index] 할지 구분 - 기준인 index 번째를 +1 한다.                            switch (classification) {                                case 'W':                                    // winCount : +1 하기 - 기준은 index 번째 이므로                                    dateChecker.addOneToWinCount(index);                                    DeveloperManager.displayLog("[F]_CalendarFragment", "[setEventDayToCheckedDate] 승리자이므로 기준 " + index + " 번째의 승리수를 +1 했습니다. / " + dateChecker.getWinCountToIndex(index));                                    continue;       // 다음 nextIndex 번째도 비교해야 하므로                                case 'L':                                    // lossCount : +1 하기 - 기준은 index 번째 이므로                                    dateChecker.addOneToLossCount(index);                                    DeveloperManager.displayLog("[F]_CalendarFragment", "[setEventDayToCheckedDate] 패배자이므로 기준 " + index + " 번째의 패배수를 +1 했습니다. / " + dateChecker.getLossCountToIndex(index));                                    continue;       // 다음 nextIndex 번째도 비교해야 하므로                                default:                                    continue;                            }                        } else {                            DeveloperManager.displayLog("[F]_CalendarFragment", "[setEventDayToCheckedDate] " + nextIndex + " 번째는 같은 날짜가 아닙니다.");                        } // check 2                    } else {                        DeveloperManager.displayLog("[F]_CalendarFragment", "[setEventDayToCheckedDate]" + nextIndex + " 번째 date 는 같은 date 가 있는지 검사하였습니다.");                    } // check A                } // cycle 2                // false 인 기준 만 승리 패배 구분 하면 됨                // check 4-1 : 기준인 index 번째의 승리 패배는 구분 안 하였므로 구분한다.                DeveloperManager.displayLog("[F]_CalendarFragment", "[setEventDayToCheckedDate] <기준>인 " + index + " 번째의 '승리' , '패배'를 구분 하겠습니다. / getName : " + userData.getName() + " /  getWinner : " + billiardDataArrayList.get(index).getWinner());                char classification = checkWinOrLoss(userData.getName(), billiardDataArrayList.get(index).getWinner());                DeveloperManager.displayLog("[F]_CalendarFragment", "[setEventDayToCheckedDate] 기준인 " + index + " 번째의 구분 결과는 : " + classification);                // check 4-2 : 위 의 classification 으로 winCount[index]+1 할지 lossCount[index] 할지 구분 - 기준이 index 이므로 index 번째에 +1 한다.                switch (classification) {                    case 'W':                        // winCount : +1 하기 - 기준은 index 번째 이므로                        dateChecker.addOneToWinCount(index);                        DeveloperManager.displayLog("[F]_CalendarFragment", "[setEventDayToCheckedDate] 승리자이므로 기준 " + index + " 번째의 승리수를 +1 했습니다. / " + dateChecker.getWinCountToIndex(index));                        DeveloperManager.displayLog("[F]_CalendarFragment", "[setEventDayToCheckedDate] ==================================================================== ");                        continue;       // 다음 nextIndex 번째도 비교해야 하므로                    case 'L':                        // lossCount : +1 하기 - 기준은 index 번째 이므로                        dateChecker.addOneToLossCount(index);                        DeveloperManager.displayLog("[F]_CalendarFragment", "[setEventDayToCheckedDate] 패배자이므로 기준 " + index + " 번째의 패배수를 +1 했습니다. / 최종 결과 수 : " + dateChecker.getLossCountToIndex(index));                        DeveloperManager.displayLog("[F]_CalendarFragment", "[setEventDayToCheckedDate] ==================================================================== ");                        continue;       // 다음 nextIndex 번째도 비교해야 하므로                    default:                        continue;                }            } else {                DeveloperManager.displayLog("[F]_CalendarFragment", "[setEventDayToCheckedDate] 기준인 " + index + " 번째는 이미 검사하였습니다.");            } // check 1        } // cycle 1        // 확인        for (int position = 0; position < billiardDataArrayList.size(); position++) {            DeveloperManager.displayLog("[F]_CalendarFragment", "[setEventDayToCheckedDate] " + position + " 번째 / checkDate : " + dateChecker.getCheckedDateToIndex(position));            DeveloperManager.displayLog("[F]_CalendarFragment", "[setEventDayToCheckedDate] " + position + " 번째 / standard : " + dateChecker.getStandardDateToIndex(position));            DeveloperManager.displayLog("[F]_CalendarFragment", "[setEventDayToCheckedDate] " + position + " 번째 / winCount : " + dateChecker.getWinCountToIndex(position));            DeveloperManager.displayLog("[F]_CalendarFragment", "[setEventDayToCheckedDate] " + position + " 번째 / LossCount : " + dateChecker.getLossCountToIndex(position));        }        // List<EventDay> : setting        List<EventDay> eventDayList = new ArrayList<>();        // cycle : DateChecker - 체크되어 있는 갑들을 모두 뒤져본다.        for (int position = 0; position < dateChecker.getArraySize(); position++) {            // check 1 : 기준 날짜이다. - position            if (dateChecker.getStandardDateToIndex(position)) {                DeveloperManager.displayLog("[F]_CalendarFragment", "[setEventDayToCheckedDate] >> 기준 날짜는 ? >> " + billiardDataArrayList.get(position).getDate() + " >> position : " + position);                // int[] : 기준 날짜의 getDate 값으로 year, month, day 로 구분하여 가져오기                int[] dateSeparationContent = changeDateToIntType(billiardDataArrayList.get(position).getDate());                DeveloperManager.displayLog("[F]_CalendarFragment", "[setEventDayToCheckedDate] >> 기준 날짜  >> winCount " + dateChecker.getWinCountToIndex(position) + " >>>>  lossCount : " + dateChecker.getLossCountToIndex(position));                // check 2 : WinCount, LossCount 가 둘다 0 이상이다.                if ((dateChecker.getWinCountToIndex(position) > 0) && (dateChecker.getLossCountToIndex(position) > 0)) {                    DeveloperManager.displayLog("[F]_CalendarFragment", "[setEventDayToCheckedDate] >> 기준 날짜로 Blue & Red로 설정합니다. >> " + billiardDataArrayList.get(position).getDate());                    // Calendar : 이벤트 날짜 셋팅                    Calendar calendar = Calendar.getInstance();                    calendar.set(dateSeparationContent[0], dateSeparationContent[1] - 1, dateSeparationContent[2]);                    // String : EventDay 에 넣을 특정 형태의 문자열 만들기//                    String dateFormat =                    // List<EventDay> : 위 의 calendar 으로 EventDay 생성하여 추가 - Blue & Red                    eventDayList.add(new EventDay(calendar, DrawableUtils.getBlueOrRedCircleDrawableWithText(getContext(), "" + dateChecker.getWinCountToIndex(position) + "  " + dateChecker.getLossCountToIndex(position))));                } else {                    // check 3 : winCount[position] 이 0 이 아니다. -> 승리자로 셋팅                    if (dateChecker.getWinCountToIndex(position) != 0) {                        DeveloperManager.displayLog("[F]_CalendarFragment", "[setEventDayToCheckedDate] >> 기준 날짜로 Blue 로 설정합니다. >> " + billiardDataArrayList.get(position).getDate());                        // Calendar : 이벤트 날짜 셋팅                        Calendar calendar = Calendar.getInstance();                        calendar.set(dateSeparationContent[0], dateSeparationContent[1] - 1, dateSeparationContent[2]);                        // List<EventDay> : 위 의 calendar 으로 EventDay 생성하여 추가 - Blue                        eventDayList.add(new EventDay(calendar, DrawableUtils.getBlueCircleDrawableWithText(getContext(), "" + dateChecker.getWinCountToIndex(position))));                    } else {                        // 위 의 값이 0 이 아니면 lossCount 가 0 이다. -> 패배자로 셋팅                        // Calendar : 이벤트 날짜 셋팅                        DeveloperManager.displayLog("[F]_CalendarFragment", "[setEventDayToCheckedDate] >> 기준 날짜로 Red 로 설정합니다. >> " + billiardDataArrayList.get(position).getDate());                        Calendar calendar = Calendar.getInstance();                        calendar.set(dateSeparationContent[0], dateSeparationContent[1] - 1, dateSeparationContent[2]);                        // List<EventDay> : 위 의 calendar 으로 EventDay 생성하여 추가 - Blue & Red                        eventDayList.add(new EventDay(calendar, DrawableUtils.getRedCircleDrawableWithText(getContext(), "" + dateChecker.getLossCountToIndex(position))));                    }                } // check 2            } else {                DeveloperManager.displayLog("[F]_CalendarFragment", "[setEventDayToCheckedDate] >> 기준 날짜가 아닙니다 >> " + position);            } // check 1            DeveloperManager.displayLog("[F]_CalendarFragment", "[setEventDayToCheckedDate] >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>");        } // cycle        // CalendarView : 위 의 내용으로 setting        calendarView.setEvents(eventDayList);        return dateChecker;    } // End of method    /* method : date 값을 billiardDataArrayList 의 getDate 값과 비교 하여 같으면 true, 다르면 false 반환하기  */    private boolean checkDateToBilliardData(String date) {        // cycle : billiardDataArrayList 의 size 만큼 순환하며 비교        for (int position = 0; position < billiardDataArrayList.size(); position++) {            DeveloperManager.displayLog("[F]_CalendarFragment", "[checkDateToBilliardData] getDate : " + date + " / getDate : " + billiardDataArrayList.get(position).getDate());            // check : billiardDate 의 getDate 와 date 가 같은 내용이다.            if (date.equals(billiardDataArrayList.get(position).getDate())) {                DeveloperManager.displayLog("[F]_CalendarFragment", "[checkDateToBilliardData] getDate 와 date 가 일치하는 곳이 있군요.");                return true;            } else {                continue;            }        }        DeveloperManager.displayLog("[F]_CalendarFragment", "[checkDateToBilliardData] getDate 와 date 가 모두 다릅니다.");        return false;    } // End of method    /**     * [method] date 값을 billiardDataArrayList 의 getDate 값과 비교 하여 같으면 position , 다르면 -1 반환     *     */    private int getPositionOfEqualDate(String date) {        // [cycle 1] : billiardDataArrayList 의 size 만큼 순환하며 비교        for (int position = 0; position < billiardDataArrayList.size(); position++) {            DeveloperManager.displayLog("[F]_CalendarFragment", "[checkDateToBilliardData] getDate : " + date + " / getDate : " + billiardDataArrayList.get(position).getDate());            // [check 1] : billiardDate 의 getDate 와 date 가 같은 내용이다.            if (date.equals(billiardDataArrayList.get(position).getDate())) {                DeveloperManager.displayLog("[F]_CalendarFragment", "[checkDateToBilliardData] getDate 와 date 가 일치하는 곳이 있군요.");                return position;            } else {                continue;            } // [check 1]        } // [cycle 1]        DeveloperManager.displayLog("[F]_CalendarFragment", "[checkDateToBilliardData] getDate 와 date 가 모두 다릅니다.");        return -1;    } // End of method [getPositionOfEqualDate]    /* method : UserData 의 getName 과 BilliardData 의 getWinner 를 비교하여 승리, 패배 구분 */    private char checkWinOrLoss(String userName, String winner) {        // check : 유저이름과 승리자가 같다. - 승리        if (userName.equals(winner)) {            return 'W';        } else {            // check : 유저이름과 승리자가 다르다. - 패배            return 'L';        }    } // End of method    /* method : date 를 year, month, day 로 구분하여 int 배열로 반환하기 */    private int[] changeDateToIntType(String date) {        /*         * ========================================================================================         * - 매개변수 형태 : "2020년 9월 30일"         * - 방식 : StringTokenizer , "년|월|일| "         *          (참고) '자바의 정석 1권' 514. StringTokenizer         * */        // int[] : 분할 한 값 담을 객체 생성        int[] dateTokenList = new int[3];        // StringTokenizer : dateTokenList 를 DATE_DELIMITER 으로 <delimiter:구분자>        StringTokenizer tokenizer = new StringTokenizer(date, DATE_DELIMITER);        // cycle : 구분된 값들이 있을 때까지 해당 값을 배열에 넣기        for (int positon = 0; tokenizer.hasMoreTokens(); positon++) {            dateTokenList[positon] = Integer.parseInt(tokenizer.nextToken());        }        return dateTokenList;    } // End of method    /**     * [method] 특정 날짜를 클릭했을 때, 그 날의 게임 정보를 보여준다.     *     */    private void showAlertToBilliardData(int position) {        // [lv/C]AlertDialog : Builder 객체 생성        AlertDialog.Builder builder = new AlertDialog.Builder(getContext());        // [lv/C]AlertDialog : 초기값 설정        builder.setTitle(R.string.ad_f_calendar_title)                .setMessage(setDisplayInfoOfBilliardData(position))                .setPositiveButton(R.string.ad_f_calendar_bt_positive, new DialogInterface.OnClickListener() {                    @Override                    public void onClick(DialogInterface dialog, int which) {                    }                })                .show();    } // End of method [showAlertToBilliardData]    /**     * [method] 임시 billiardData 를 보기 좋게 만들기     *     * @param position billiardDataArrayList 에서 선택 된 billiard 데이터의 position     * @return 해당 billiard 데이터를 특정 형태의 문자열로 변환한 값     */    private String setDisplayInfoOfBilliardData(int position) {        String temp = null;        StringBuilder billiardInfo = new StringBuilder();        // [check 1] : billiardDataArrayList 의 size 가 0 이 아님        if (this.billiardDataArrayList.size() != 0) {            // 1. count            billiardInfo.append("1. 번호 : ");            billiardInfo.append(this.billiardDataArrayList.get(position).getCount());            billiardInfo.append("\n");            // 2. date            billiardInfo.append("2. 날짜 : ");            billiardInfo.append(this.billiardDataArrayList.get(position).getDate());            billiardInfo.append("\n");            //  3. target score            billiardInfo.append("3. 수지 : ");            billiardInfo.append(this.billiardDataArrayList.get(position).getTargetScore());            billiardInfo.append("\n");            //  3. target score            billiardInfo.append("4. 종목 : ");            billiardInfo.append(this.billiardDataArrayList.get(position).getSpeciality());            billiardInfo.append("\n");            //  3. target score            billiardInfo.append("5. 승리자 : ");            billiardInfo.append(this.billiardDataArrayList.get(position).getWinner());            billiardInfo.append("\n");            //  3. target score            billiardInfo.append("6. 스코어 : ");            billiardInfo.append(this.billiardDataArrayList.get(position).getScore());            billiardInfo.append("\n");            //  3. target score            billiardInfo.append("7. 게임 시간 : ");            billiardInfo.append(this.billiardDataArrayList.get(position).getPlayTime());            billiardInfo.append("\n");            //  3. target score            billiardInfo.append("8. 가격 : ");            billiardInfo.append(this.billiardDataArrayList.get(position).getCost());            billiardInfo.append("\n");        } else {            DeveloperManager.displayLog("[F]_CalendarFragment", "[setInfoToBilliardData] billiardDataArrayList 에 데이터가 없습니다. / size : " + this.billiardDataArrayList.size());        } // [check 1]        return billiardInfo.toString();    } // End of method [setDisplayInfoOfBilliardData]    /**     * [method] 클래스 멤버 변수를 이용하여 calendar view 의 EventDay 를 셋팅하기     *     * 같은 날짜일 때 중복 된 승패를 표현하지 못 함.     */    private void setEventDayOfWinOrLoss() {            // check 2 : userData 내용이 있다.            if (userData != null) {                // check 3 : billiardDbManager 가 초기화 되었다.                if (billiardDbManager.isInitializedDB()) {                    // check 4 : billiardDataArrayList 의 size 가 0 이 아니다.                    if (billiardDataArrayList.size() != 0) {                        // cycle : billiardDataArrayList 를 size 만큼 돌면서 getDate 값을 확인                        for (int position = 0; position < billiardDataArrayList.size(); position++) {                            // tokenizer : billiardData 의 date 를 year, month, day 로 구분한 배열 - [0]:year, [1]:month, [2]:day                            int[] dateTokenList = changeDateToIntType(billiardDataArrayList.get(position).getDate());                            // check 5-1 : 나는 승리했나? 패배했나?                            char classification = checkWinOrLoss(userData.getName(), billiardDataArrayList.get(position).getWinner());                            // check 5-2 : 위 의 classification 값이 뭐임? - 'W':나의 승리, 'L':나의 패배                            switch (classification) {                                case 'W':                                    // List<EventDay> : eventDayList 에 내용 추가 - EventDay 는 하나의 ArrayList 로 관리한다.                                    DeveloperManager.displayLog("[F]_CalendarFragment", "[setEventDayToBilliardData] Win : [0]-" + dateTokenList[0] + " / [1]-" + dateTokenList[1] + " / [2]-" + dateTokenList[2]);                                    Calendar calendarWin = Calendar.getInstance();                                    calendarWin.set(dateTokenList[0], dateTokenList[1] - 1, dateTokenList[2]);                                    eventDayList.add(new EventDay(calendarWin, DrawableUtils.getBlueCircleDrawableWithText(getContext(), "W")));                                    continue;                                case 'L':                                    // List<EventDay> : eventDayList 에 내용 추가 - EventDay 는 하나의 ArrayList 로 관리한다.                                    DeveloperManager.displayLog("[F]_CalendarFragment", "[setEventDayToBilliardData] L : [0]-" + dateTokenList[0] + " / [1]-" + dateTokenList[1] + " / [2]-" + dateTokenList[2]);                                    Calendar calendarLoss = Calendar.getInstance();                                    calendarLoss.set(dateTokenList[0], dateTokenList[1] - 1, dateTokenList[2]);                                    eventDayList.add(new EventDay(calendarLoss, DrawableUtils.getRedCircleDrawableWithText(getContext(), "L")));                                    continue;                                default:                                    // 'W'와 'L'이 아닌 값들은 billiardData 나 userData 에 이상한 값들이 있는 거야!                                    break;                            } // End of check : switch                        } // End of cycle : for                        // CalendarView : 위 의 for 구문으로 구분된 EventDay 가 저장된 eventDayList 로 setting.                        calendarView.setEvents(eventDayList);                    } else {                        DeveloperManager.displayLog("[F]_CalendarFragment", "[setEventDayToBilliardData] billiard 테이블에 저장된 내용이 없습니다.");                    } // End of check 4                } else {                    DeveloperManager.displayLog("[F]_CalendarFragment", "[setEventDayToBilliardData] billiardDbManager 가 초기화 되지 않았습니다. : " + billiardDbManager.isInitializedDB());                } // End of check 3            } else {                DeveloperManager.displayLog("[F]_CalendarFragment", "[setEventDayToBilliardData] user 테이블에 저장된 내용이 없습니다. ");            } // End of check 2    } // End of method    /**     * [method] date 를 year, month, day 로 구분하여 ArrayList<String> 으로 반환하기     *     */    private ArrayList<String> changeDateToStringArray(String date) {        /*         * ========================================================================================         * - 매개변수 형태 : "2020년 9월 30일"         * - 방식 : StringTokenizer , "년|월|일| "         *          (참고) '자바의 정석 1권' 514. StringTokenizer         * */        // ArrayList<String> : 분할 한 값 담을 객체 생성        ArrayList<String> dateTokenList = new ArrayList<>();        // StringTokenizer : dateTokenList 를 DATE_DELIMITER 으로 <delimiter:구분자>        StringTokenizer tokenizer = new StringTokenizer(date, DATE_DELIMITER);        // cycle : 구분된 값들이 있을 때까지 해당 값을 배열에 넣기        while (tokenizer.hasMoreTokens()) {            dateTokenList.add(tokenizer.nextToken());        }        return dateTokenList;    } // End of method}