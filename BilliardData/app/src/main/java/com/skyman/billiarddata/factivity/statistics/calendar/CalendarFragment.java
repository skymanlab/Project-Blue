package com.skyman.billiarddata.factivity.statistics.calendar;import android.app.AlertDialog;import android.content.DialogInterface;import android.os.Bundle;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import androidx.annotation.NonNull;import androidx.annotation.Nullable;import androidx.fragment.app.Fragment;import com.applandeo.materialcalendarview.CalendarView;import com.applandeo.materialcalendarview.EventDay;import com.applandeo.materialcalendarview.listeners.OnDayClickListener;import com.skyman.billiarddata.R;import com.skyman.billiarddata.developer.DeveloperManager;import com.skyman.billiarddata.dialog.BilliardInfo;import com.skyman.billiarddata.factivity.statistics.calendar.Utils.DrawableUtils;import com.skyman.billiarddata.management.billiard.data.BilliardData;import com.skyman.billiarddata.management.billiard.database.BilliardDBManager;import com.skyman.billiarddata.management.projectblue.data.ProjectBlueDataFormatter;import com.skyman.billiarddata.management.user.data.UserData;import com.skyman.billiarddata.management.user.database.UserDbManager;import java.util.ArrayList;import java.util.Calendar;import java.util.List;import java.util.StringTokenizer;/** * A simple {@link Fragment} subclass. * Use the {@link CalendarFragment#newInstance} factory method to * create an instance of this fragment. */public class CalendarFragment extends Fragment {    // TODO: Rename parameter arguments, choose names that match    // the fragment initialization parameters, e.g. ARG_ITEM_NUMBER    private static final String ARG_PARAM1 = "param1";    private static final String ARG_PARAM2 = "param2";    // constant    private final String DATE_DELIMITER = "년월일 ";    // instance variable    private CalendarView calendarView;    private List<EventDay> eventDayList = new ArrayList<>();    // instance variable    private BilliardDBManager billiardDbManager;    private UserDbManager userDbManager;    private UserData userData = null;    private ArrayList<BilliardData> billiardDataArrayList = null;    private DateChecker dateChecker = null;    // TODO: Rename and change types of parameters    private String mParam1;    private String mParam2;    // constructor    public CalendarFragment(UserDbManager userDbManager, BilliardDBManager billiardDBManager, UserData userData, ArrayList<BilliardData> billiardDataArrayList) {        this.userDbManager = userDbManager;        this.billiardDbManager = billiardDBManager;        this.userData = userData;        this.billiardDataArrayList = billiardDataArrayList;    }    // constructor    public CalendarFragment() {        // Required empty public constructor    }    /**     * Use this factory method to create a new instance of     * this fragment using the provided parameters.     *     * @param param1 Parameter 1.     * @param param2 Parameter 2.     * @return A new instance of fragment CalendarFragment.     */    // TODO: Rename and change types and number of parameters    public static CalendarFragment newInstance(String param1, String param2) {        CalendarFragment fragment = new CalendarFragment();        Bundle args = new Bundle();        args.putString(ARG_PARAM1, param1);        args.putString(ARG_PARAM2, param2);        fragment.setArguments(args);        return fragment;    }    @Override    public void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        if (getArguments() != null) {            mParam1 = getArguments().getString(ARG_PARAM1);            mParam2 = getArguments().getString(ARG_PARAM2);        }    }    @Override    public View onCreateView(LayoutInflater inflater, ViewGroup container,                             Bundle savedInstanceState) {        // Inflate the layout for this fragment        return inflater.inflate(R.layout.fragment_calendar, container, false);    }    @Override    public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {        super.onViewCreated(view, savedInstanceState);        DeveloperManager.displayLog("[F]_CalendarFragment", "[onViewCreated] userData 확인 : " + this.userData);        DeveloperManager.displayToUserData("[F]_CalendarFragment", this.userData);        DeveloperManager.displayLog("[F]_CalendarFragment", "[onViewCreated] billiardDataArrayList 확인 : " + this.billiardDataArrayList);        DeveloperManager.displayToBilliardData("[F]_CalendarFragment", this.billiardDataArrayList);        // [iv/C]CalendarView : calendarView mapping        this.calendarView = (CalendarView) view.findViewById(R.id.f_calendar_cv_game_record);        // [check 1] : userData 와 billiardDataArrayList 가 모두 있다. 즉, EventDay 를 구할 method 를 실행할 준비가 되었다.        if (checkWhetherFindEventsDay()) {            this.dateChecker = makeDateCheckerWithAllBilliardData(this.userData, this.billiardDataArrayList);            // [method] : userData 와 billiardDataArrayList 로 DateChecker 를 만든다. 그리고 이 DateChecker 를 통해 EventDay 만들고 calendarView 에 설정한다.            setEventsDayWithUserDataAndAllBilliardData(this.dateChecker);        } else {            DeveloperManager.displayLog("[F]_CalendarFragment", "[onViewCreated] userData 와 billiardDataArrayList 가 없으므로 달력에 표시할 EventDay 가 없습니다.");        } // [check 1]        // [iv/C]CalendarView : calendarView date click listener        this.calendarView.setOnDayClickListener(new OnDayClickListener() {            @Override            public void onDayClick(EventDay eventDay) {                // [lv/C]String : 클릭 한 날의 eventDay 로 Date 형태의 객체 받아오기                String dateContent = ProjectBlueDataFormatter.getFormatOfDate(eventDay.getCalendar().getTime());                DeveloperManager.displayLog("[F]_CalendarFragment", "[calendarView button] " + dateContent);                // [lv/i]position : 위에서 구한 날짜가 billiardDataArrayList 에서 같은 날짜가 있으면 그 index 를 반환                int position = getPositionOfEqualDate(dateContent);                DeveloperManager.displayLog("[F]_CalendarFragment", "[calendarView button] positon : " + getPositionOfEqualDate(dateContent));                // [check 1] : position 이 있다.                if (position >= 0) {                    // [check 2] : dataChecker 의 getArraySize 가 0 이 아니다.                    if (dateChecker.getArraySize() != 0) {                        // [lv/C]BilliardInfo : custom 한 dialog 를 생성하기                        BilliardInfo billiardInfo = new BilliardInfo(getContext(), dateChecker, billiardDataArrayList, position);                        // [lv/C]BilliardInfo : dialog 만들고 화면에 출력하기                        billiardInfo.setDialog();                    } else {                    } // [check 2]                } else {                }// [check 1]            }        });    } // End of method [onViewCreated]    /*                                      private method     * =============================================================================================     * =============================================================================================     * */    /**     * [method] date 값을 billiardDataArrayList 의 getDate 값과 비교 하여 같으면 position , 다르면 -1 반환     */    private int getPositionOfEqualDate(String date) {        // [cycle 1] : billiardDataArrayList 의 size 만큼 순환하며 비교        for (int position = 0; position < billiardDataArrayList.size(); position++) {            DeveloperManager.displayLog("[F]_CalendarFragment", "[checkDateToBilliardData] getDate : " + date + " / getDate : " + billiardDataArrayList.get(position).getDate());            // [check 1] : billiardDate 의 getDate 와 date 가 같은 내용이다.            if (date.equals(billiardDataArrayList.get(position).getDate())) {                DeveloperManager.displayLog("[F]_CalendarFragment", "[checkDateToBilliardData] getDate 와 date 가 일치하는 곳이 있군요.");                return position;            } else {                continue;            } // [check 1]        } // [cycle 1]        DeveloperManager.displayLog("[F]_CalendarFragment", "[checkDateToBilliardData] getDate 와 date 가 모두 다릅니다.");        return -1;    } // End of method [getPositionOfEqualDate]    /**     * [method] 특정 날짜를 클릭했을 때, 그 날의 게임 정보를 보여준다.     */    private void showAlertToBilliardData(int position) {        // [lv/C]AlertDialog : Builder 객체 생성        AlertDialog.Builder builder = new AlertDialog.Builder(getContext());        // [lv/C]AlertDialog : 초기값 설정        builder.setTitle(R.string.ad_f_calendar_title)                .setMessage(setDisplayInfoOfBilliardData(position))                .setPositiveButton(R.string.ad_f_calendar_bt_positive, new DialogInterface.OnClickListener() {                    @Override                    public void onClick(DialogInterface dialog, int which) {                    }                })                .show();    } // End of method [showAlertToBilliardData]    /**     * [method] 임시 billiardData 를 보기 좋게 만들기     *     * @param position billiardDataArrayList 에서 선택 된 billiard 데이터의 position     * @return 해당 billiard 데이터를 특정 형태의 문자열로 변환한 값     */    private String setDisplayInfoOfBilliardData(int position) {        String temp = null;        StringBuilder billiardInfo = new StringBuilder();        // [check 1] : billiardDataArrayList 의 size 가 0 이 아님        if (this.billiardDataArrayList.size() != 0) {            // 1. count            billiardInfo.append("1. 번호 : ");            billiardInfo.append(this.billiardDataArrayList.get(position).getCount());            billiardInfo.append("\n");            // 2. date            billiardInfo.append("2. 날짜 : ");            billiardInfo.append(this.billiardDataArrayList.get(position).getDate());            billiardInfo.append("\n");            //  3. target score            billiardInfo.append("3. 수지 : ");            billiardInfo.append(this.billiardDataArrayList.get(position).getTargetScore());            billiardInfo.append("\n");            //  3. speciality            billiardInfo.append("4. 종목 : ");            billiardInfo.append(this.billiardDataArrayList.get(position).getSpeciality());            billiardInfo.append("\n");            //  3. winner            billiardInfo.append("5. 승리자 : ");            billiardInfo.append(this.billiardDataArrayList.get(position).getWinner());            billiardInfo.append("\n");            //  3. score            billiardInfo.append("6. 스코어 : ");            billiardInfo.append(this.billiardDataArrayList.get(position).getScore());            billiardInfo.append("\n");            //  3. play time            billiardInfo.append("7. 게임 시간 : ");            billiardInfo.append(this.billiardDataArrayList.get(position).getPlayTime());            billiardInfo.append("\n");            //  3. cost            billiardInfo.append("8. 가격 : ");            billiardInfo.append(this.billiardDataArrayList.get(position).getCost());            billiardInfo.append("\n");        } else {            DeveloperManager.displayLog("[F]_CalendarFragment", "[setInfoToBilliardData] billiardDataArrayList 에 데이터가 없습니다. / size : " + this.billiardDataArrayList.size());        } // [check 1]        return billiardInfo.toString();    } // End of method [setDisplayInfoOfBilliardData]    /**     * [method] userData 와 billiardDataArrayList 가 null 이 아닌지를 검사한다.     */    private boolean checkWhetherFindEventsDay() {        // [check 1] : userData 가 있고 billiardDataArrayList 에 데이터가 있습니다.        if ((userData != null) && (this.billiardDataArrayList.size() != 0)) {            DeveloperManager.displayLog("[F]_CalendarFragment", "[checkWhetherFindEventsDay] userData, billiardDataArrayList 가 모두 있습니다. EventDay 를 구하는 작업을 해도 됩니다.");            return true;        } else {            DeveloperManager.displayLog("[F]_CalendarFragment", "[checkWhetherFindEventsDay] userData 가 없고, billiardDataArrayList 에 데이터도 없습니다.");            return false;        } // [check 1]    } // End of method [checkWhetherFindEventsDay]    // ==========================================================================================================================================    /**     * [method] billiardDataArrayList 를 가지고 각 날짜의 win 과 loss 카운트하여 DateChecker 를 만든다.     * 그리고 이 DateChecker 를 통해 기준 날짜의 EventDay 를 만들어 eventDayArrayList 에 추가한다.     * 마지막으로 이 eventDayArrayList 를 calendarView 에 설정한다.     */    private DateChecker setEventsDayWithUserDataAndAllBilliardData(DateChecker dateChecker) {//        DateChecker dateChecker =        // [check 1] : DateChecker 가 있다.        if (dateChecker.getArraySize() != 0) {            // [cycle 1] : DateChecker 의 size 만큼            for (int position = 0; position < billiardDataArrayList.size(); position++) {                DeveloperManager.displayLog("[F]_CalendarFragment", "[setEventsDayWithUserDataAndAllBilliardData] " + position + " 번째 / standard : " + dateChecker.getStandardDateToIndex(position));                DeveloperManager.displayLog("[F]_CalendarFragment", "[setEventsDayWithUserDataAndAllBilliardData] " + position + " 번째 / winCount : " + dateChecker.getWinCountToIndex(position));                DeveloperManager.displayLog("[F]_CalendarFragment", "[setEventsDayWithUserDataAndAllBilliardData] " + position + " 번째 / LossCount : " + dateChecker.getLossCountToIndex(position));                DeveloperManager.displayLog("[F]_CalendarFragment", "[setEventsDayWithUserDataAndAllBilliardData] " + position + " 번째 / WinCounter - winCount : " + dateChecker.getWinCounterToIndex(position).getWinCount());                DeveloperManager.displayLog("[F]_CalendarFragment", "[setEventsDayWithUserDataAndAllBilliardData] " + position + " 번째 / LossCounter - lossCount : " + dateChecker.getLossCounterToIndex(position).getLossCount());                ArrayList<Long> billiardWin = dateChecker.getWinCounterToIndex(position).getBilliardCount();                // [cycle 2] : 같은 날짜여서 WinCounter 의 billiardCount 에 저장된 getCount 번호 모두 출력                for (int winIndex = 0; winIndex < billiardWin.size(); winIndex++) {                    DeveloperManager.displayLog("[F]_CalendarFragment", "[setEventsDayWithUserDataAndAllBilliardData] " + position + " 번째 / WinCounter 의 " + winIndex + " 번째 billiard getCount 는 : " + billiardWin.get(winIndex));                } // [cycle 2]                ArrayList<Long> billiardLoss = dateChecker.getLossCounterToIndex(position).getBilliardCount();                // [cycle 3] : 같은 날짜여서 LossCounter 의 billiardCount 에 저장된 getCount 번호 모두 출력                for (int lossIndex = 0; lossIndex < billiardLoss.size(); lossIndex++) {                    DeveloperManager.displayLog("[F]_CalendarFragment", "[setEventsDayWithUserDataAndAllBilliardData] " + position + " 번째 / LossCounter 의 " + lossIndex + " 번째 billiard getCount 는 : " + billiardLoss.get(lossIndex));                } // [cycle 3]                ArrayList<Long> billiardCount = dateChecker.getBilliardCountToIndex(position);                // [cycle 3] : 같은 날짜여서 LossCounter 의 billiardCount 에 저장된 getCount 번호 모두 출력                for (int countIndex = 0; countIndex < billiardCount.size(); countIndex++) {                    DeveloperManager.displayLog("[F]_CalendarFragment", "[setEventsDayWithUserDataAndAllBilliardData] " + position + " 번째 / billiardCount 의 " + countIndex + " 번째 billiard getCount 는 : " + billiardCount.get(countIndex));                } // [cycle 3]                ArrayList<DateChecker.BilliardCounter> winLosses = dateChecker.getWinLossToIndex(position);                // [cycle 4] : WinLoss 로                for (int index = 0; index < winLosses.size(); index++) {                    DeveloperManager.displayLog("[F]_CalendarFragment", "[setEventsDayWithUserDataAndAllBilliardData] " + position + " 번째 / winLosses 의 " + index + " 번째 billiard getCount 는 : " + winLosses.get(index).getBilliardCount() + " 그리고 [" + winLosses.get(index).getWinOrLoss() + "] 입니다.");                }            } // [cycle 1]            // List<EventDay> : setting            List<EventDay> eventDayList = makeEventDayArrayWithDateChecker(this.billiardDataArrayList, dateChecker);            // CalendarView : 위 의 내용으로 setting            calendarView.setEvents(eventDayList);        } else {            DeveloperManager.displayLog("[F]_CalendarFragment", "[setEventsDayWithUserDataAndAllBilliardData] dateChecker 가 없습니다. 즉, billiardDataArrayList 가 없어서 만들어지지 않았습니다.  ");        } // [check 1]        return dateChecker;    } // End of method [setEventsDayWithUserDataAndAllBilliardData]    // ==========================================================================================================================================    /**     * [method] billiardDataArrayList 로 DateChecker 를 만들기     */    private DateChecker makeDateCheckerWithAllBilliardData(UserData userData, ArrayList<BilliardData> billiardDataArrayList) {        // DateChecker : 각 date 에 win 과 loss 가 몇 개인지 구분        DateChecker dateChecker = new DateChecker(billiardDataArrayList.size());        dateChecker.initArray();        // cycle 1 : billiardDataArrayList 의 Date 를 가져와 중복 date 를 찾아 체크하고, 그 date 의 win 과 loss 의 수를 구한다.        for (int index = 0; index < billiardDataArrayList.size(); index++) {            // check 1 : checkedDate[index] 의 값이 false 일 때 - 체크 안 된 date            if (!dateChecker.getCheckedDateToIndex(index)) {                DeveloperManager.displayLog("[F]_CalendarFragment", "[makeDateCheckerWithAllBilliardData] ======================= 기준인 " + index + " 번째 date : " + billiardDataArrayList.get(index).getDate() + " =======================");                // DateChecker : 위 의 check 1 을 수행 하였으므로 index 번째를 true 로 - checkedDate                dateChecker.setTrueToCheckedDate(index);                // DateChecker : 위 의 check 1 을 수행 하였으므로 index 번째를 true 로 - checkedDate                dateChecker.setTrueToStandardDate(index);                // [check 2] : 나의 이름과 index 번째의 winner 의 이름과 같다. 즉, 내가 승리한 게임이다. / method : compareUserNameWithWinner                if (compareUserNameWithWinner(userData.getName(), billiardDataArrayList.get(index).getWinner())) {                    dateChecker.addOneToWinCount(index);                    dateChecker.addOneToWinCountOfWinCounter(index);                    dateChecker.addBilliardCountOfWinCounter(index, billiardDataArrayList.get(index).getCount());                    dateChecker.addBilliardCountToIndex(index, billiardDataArrayList.get(index).getCount());                    dateChecker.addBilliardCountToIndex(index, new DateChecker.BilliardCounter('W', billiardDataArrayList.get(index).getCount()));                    DeveloperManager.displayLog("[F]_CalendarFragment", "[makeDateCheckerWithAllBilliardData] <" + index + "> index 번째는 내가 승리한 게임입니다. 기준 index 번째의 winCount + 1 을 수행하였습니다.");                } else {                    dateChecker.addOneToLossCount(index);                    dateChecker.addOneToLossCountOfLossCounter(index);                    dateChecker.addBilliardCountOfLossCounter(index, billiardDataArrayList.get(index).getCount());                    dateChecker.addBilliardCountToIndex(index, billiardDataArrayList.get(index).getCount());                    dateChecker.addBilliardCountToIndex(index, new DateChecker.BilliardCounter('L', billiardDataArrayList.get(index).getCount()));                    DeveloperManager.displayLog("[F]_CalendarFragment", "[makeDateCheckerWithAllBilliardData] <" + index + "> index 번째는 내가 승리한 게임입니다. 기준 index 번째의 lossCount + 1 을 수행하였습니다.");                } // [check 2]                // cycle 2 : [index+1] 인 배열부터 배열 끝 까지 date 가 같은지 비교                for (int nextIndex = index + 1; nextIndex < billiardDataArrayList.size(); nextIndex++) {                    DeveloperManager.displayLog("[F]_CalendarFragment", "[makeDateCheckerWithAllBilliardData] >>>>>>>>>>>>>>>>> 비교 nextIndex 는 " + nextIndex + " 입니다. >>>>>>>>>>>>>>>> ");                    compareIndexWithNextIndex(userData, billiardDataArrayList, dateChecker, index, nextIndex);                } // cycle 2            } else {                DeveloperManager.displayLog("[F]_CalendarFragment", "[makeDateCheckerWithAllBilliardData] =======================  기준인 " + index + " 번째는 이미 검사하였습니다.  ======================= ");            } // check 1        } // cycle 1        return dateChecker;    } // End of method [makeDateCheckerWithAllBilliardData]    /**     * [method] billiardDataArrayList 의 index 와 nextIndex 번째의 date 가 같은지 비교하여 win, loss 구분한다.     *     * @param userData              유저의 데이터     * @param billiardDataArrayList 비교하는 데이터가 담긴 ArrayList     * @param dateChecker     * @param index                 기준 날짜의 index     */    private void compareIndexWithNextIndex(UserData userData, ArrayList<BilliardData> billiardDataArrayList, DateChecker dateChecker, int index, int nextIndex) {        //  [check 1] : dateChecker / nextIndex 번째의 'checkedDate' 가 false 이다.        if (!dateChecker.getCheckedDateToIndex(nextIndex)) {            // [check 2] : billiardDataArrayList / index 번째와 nextIndex 번째의 date 가 같다. / method : compareDateOfBilliardData            if (compareDateOfBilliardData(billiardDataArrayList, index, nextIndex)) {                // [lv/C]DateChecker : nextIndex 번째의 'checkedData' 를 true 로 바꾼다. 즉, 같은 날짜이므로 체크한 날짜로 바꾸는 것이다.                dateChecker.setTrueToCheckedDate(nextIndex);                // [check 3] : nextIndex 번째의 winner 와 userName 이 같다. 즉, 내가 승리한 게임이다. / method : compareUserNameWithWinner                if (compareUserNameWithWinner(userData.getName(), billiardDataArrayList.get(nextIndex).getWinner())) {                    // [lv/C]DateChecker : index 번째의 'winCount' 를 +1 한다. 즉, 비교한 nextIndex 번째의 'windCount' 의 초기값 0 그대로이다.                    dateChecker.addOneToWinCount(index);                    dateChecker.addOneToWinCountOfWinCounter(index);                    dateChecker.addBilliardCountOfWinCounter(index, billiardDataArrayList.get(nextIndex).getCount());                    dateChecker.addBilliardCountToIndex(index, billiardDataArrayList.get(nextIndex).getCount());                    dateChecker.addBilliardCountToIndex(index, new DateChecker.BilliardCounter('W', billiardDataArrayList.get(nextIndex).getCount()));                    DeveloperManager.displayLog("[F]_CalendarFragment", "[compareIndexWithNextIndex] <" + nextIndex + "> nextIndex 번째는 내가 승리한 게임입니다. 결과 : " + dateChecker.getWinCountToIndex(index));                } else {                    // [lv/C]DateChecker : index 번째의 lossCount 를 +1 한다. 즉, 비교한 nextIndex 번째는 'lossCount' 의 초기값 0 그대로이다.                    dateChecker.addOneToLossCount(index);                    dateChecker.addOneToLossCountOfLossCounter(index);                    dateChecker.addBilliardCountOfLossCounter(index, billiardDataArrayList.get(nextIndex).getCount());                    dateChecker.addBilliardCountToIndex(index, billiardDataArrayList.get(nextIndex).getCount());                    dateChecker.addBilliardCountToIndex(index, new DateChecker.BilliardCounter('L', billiardDataArrayList.get(nextIndex).getCount()));                    DeveloperManager.displayLog("[F]_CalendarFragment", "[compareIndexWithNextIndex] <" + nextIndex + "> nextIndex 번째는 내가 패배한 게임입니다. 결화 : " + dateChecker.getLossCountToIndex(index));                } // [check 3]            } else {                DeveloperManager.displayLog("[F]_CalendarFragment", "[compareIndexWithNextIndex]  <" + nextIndex + "> nextIndex 번째의 date 는 기준 index 번째의 date 와 다릅니다. 다음 nextIndex+1 값과 비교합니다.");            } // [check 2]        } else {            DeveloperManager.displayLog("[F]_CalendarFragment", "[compareIndexWithNextIndex]  <" + nextIndex + "> nextIndex 번째의 checkedDate 는 true 이므로 기준 date 와 비교하지 않아도 됩니다.");        } // [check 1]    } // End of method [compareIndexWithNextIndex]    /**     * [method] index 과 nextIndex 의 date 를 비교하여 같으면 nextIndex 를 검사한 날짜로 체크하기     *     * @param billiardDataArrayList     * @param index     * @param nextIndex     * @return billiardDataArrayList 를 index 번재와 nextIndex 번째의 date 를 비교한 결과를 반환한다.     */    private boolean compareDateOfBilliardData(ArrayList<BilliardData> billiardDataArrayList, int index, int nextIndex) {        DeveloperManager.displayLog("[F]_CalendarFragment", "[compareDateOfBilliardData] <" + nextIndex + "> index 번째 date : " + billiardDataArrayList.get(index).getDate() + " / nextIndex 번째 date : " + billiardDataArrayList.get(nextIndex).getDate());        // [lv/b]isSameDate : 두 개의 날짜가 같은 날짜인지 구분        boolean isSameDate;        // [check 1] : index 번째와 nextIndex 번째의 date 가 같다.        if (billiardDataArrayList.get(index).getDate().equals(billiardDataArrayList.get(nextIndex).getDate())) {            DeveloperManager.displayLog("[F]_CalendarFragment", "[compareDateOfBilliardData]  <" + nextIndex + "> index 와 nextIndex 번째는 같은 날짜입니다.");            isSameDate = true;        } else {            DeveloperManager.displayLog("[F]_CalendarFragment", "[compareDateOfBilliardData] <" + nextIndex + "> index 와 nextIndex 번째는 다른 날짜입니다.");            isSameDate = false;        } // [check 1]        return isSameDate;    } // End of method [compareDateOfBilliardData]    /**     * [method] userName 과 winner 가 같은 때, true 를 반환한다.     *     * @param userName userData 의 name     * @param winner   billiardData 의 winner 의 name     * @return userName 과 winner 를 비교한 결과     */    private boolean compareUserNameWithWinner(String userName, String winner) {        DeveloperManager.displayLog("[F]_CalendarFragment", "[compareUserNameWithWinner] user name : " + userName + " / winner : " + winner);        // [lv/b]isSameName : userName 과 winner 를 비교한 결과        boolean isSameName;        // [check 1] : userName 이 승리했다.        if (userName.equals(winner)) {            DeveloperManager.displayLog("[F]_CalendarFragment", "[compareUserNameWithWinner] userName : " + userName + " 은 승리했습니다.");            isSameName = true;        } else {            DeveloperManager.displayLog("[F]_CalendarFragment", "[compareUserNameWithWinner] userName : " + userName + " 은 패배했습니다.");            isSameName = false;        } // [check 1]        return isSameName;    } // End of method [compareUserNameWithWinner]    // ==========================================================================================================================================    /**     * [method] DateChecker 으로 EventDay 를 만들어 ArrayList<EventDay> 로 만들어서 반환한다.     */    private ArrayList<EventDay> makeEventDayArrayWithDateChecker(ArrayList<BilliardData> billiardDataArrayList, DateChecker dateChecker) {        // [lv/C]ArrayList<EventDay> : 데이터를 담을 객체 생성        ArrayList<EventDay> eventDayArrayList = new ArrayList<>();        // [cycle 1] : DateChecker - 체크되어 있는 갑들을 모두 뒤져본다.        for (int position = 0; position < dateChecker.getArraySize(); position++) {            DeveloperManager.displayLog("[F]_CalendarFragment", "[makeEventDayArrayWithDateChecker] >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>");            // [check 1] : 기준 날짜이다. - position            if (dateChecker.getStandardDateToIndex(position)) {                DeveloperManager.displayLog("[F]_CalendarFragment", "[makeEventDayArrayWithDateChecker] >> 기준 날짜는 ? >> " + billiardDataArrayList.get(position).getDate() + " >> position : " + position);                // [lv/C]Calendar : billiardData 의 date 로 Calendar 객체 만들기                Calendar calendar = setCalendarWithDateItems(changeDateToIntArrayType(billiardDataArrayList.get(position).getDate()));                // [method]checkEventDayType : dateChecker 의 winCount, lossCount 로 EventDay 의 유형을 구분하여 eventDayList 에 추가하기                checkEventDayType(dateChecker.getWinCountToIndex(position), dateChecker.getLossCountToIndex(position), calendar, eventDayArrayList);            } else {                DeveloperManager.displayLog("[F]_CalendarFragment", "[makeEventDayArrayWithDateChecker] >> 기준 날짜가 아닙니다 >> " + position);            } // [check 1]        } // [cycle 1]        return eventDayArrayList;    } // End of method [makeEventDayArrayWithDateChecker]    /**     * [method] date 문자열을 StringTokenizer 로 구분한 뒤, 각 문자열을 int 로 parse 한 다음 배열에 담아 반환한다.     *     * @param date 날짜 문자열     * @return 분할 된 날짜가 integer 로 변환되어 담긴 배열     */    private int[] changeDateToIntArrayType(String date) {        // [lv/i]dateTokenList : 매개변수 문자열이 분할되어 integer 로 parsing 된 다음 저장될 변수        int[] dateTokenList = new int[3];        // [lv/C]StringTokenizer : 매개변수 문자열을 '년월일 ' 로 나누기 / DATE_DELIMITER : '년월일 ' / delimiter : 구분자        StringTokenizer tokenizer = new StringTokenizer(date, DATE_DELIMITER);        // [cycle 1] : 구분된 값들이 있을 때까지 해당 값을 배열에 넣기        for (int positon = 0; tokenizer.hasMoreTokens(); positon++) {            // [lv/i]dateTokenList : 분할 된 토큰을 year, month, day 순으로 integer 로 parsing 한 값을 담는다.            dateTokenList[positon] = Integer.parseInt(tokenizer.nextToken());        } // [cycle 1]        return dateTokenList;    } // End of method [changeDateToIntArrayType]    /**     * [method] year, month, day 로 Calendar 객체 만들기     *     * @param dateItem int 타입의 year, month, day 담겨있는 배열     * @return 해당 날짜로 만들어진 Calendar 객체     */    private Calendar setCalendarWithDateItems(int[] dateItem) {        // [lv/C]Calendar : 객체 선언        Calendar calendar = null;        // [check 1] : dataItem 의 length 가 3 이다.        if (dateItem.length == 3) {            // [lv/C]Calendar : 객체 생성            calendar = Calendar.getInstance();            // [lv/C]Calendar : 매개변수 값으로 날짜 설정하기            calendar.set(dateItem[0], dateItem[1] - 1, dateItem[2]);        } else {            DeveloperManager.displayLog("[F]_CalendarFragment", "[setCalendarWithDateItems] dateItem 의 length 는 3 이어야 합니다. 왜냐면 year, month, day 만 저장되어있는 array variable 이기 때문입니다.");        }        return calendar;    } // End of method [setCalendarWithDateItems]    /**     * [method] winCount, lossCount 가 값이 있는지로 EventDay 의 type 을 결정     */    private void checkEventDayType(int winCount, int lossCount, Calendar calendar, ArrayList<EventDay> eventDayList) {        // [check 2] : WinCount, LossCount 을 구분한다.        if ((winCount > 0) && (lossCount > 0)) {            // 승리, 패배 모두 있다.            DeveloperManager.displayLog("[F]_CalendarFragment", "[checkEventDayType] >> 기준 날짜로 Blue & Red로 설정합니다. >>");            // [lv/C]ArrayList<EventDay> : calendar 으로 EventDay 생성하여 추가 - Blue & Red            eventDayList.add(new EventDay(calendar, DrawableUtils.getBlueOrRedCircleDrawableWithText(getContext(), "" + winCount + "  " + lossCount)));        } else if ((winCount > 0) && (lossCount == 0)) {            // 승리만 있다.            DeveloperManager.displayLog("[F]_CalendarFragment", "[checkEventDayType] >> 기준 날짜로 Blue 로 설정합니다. >> ");            // List<EventDay> : 위 의 calendar 으로 EventDay 생성하여 추가 - Blue            eventDayList.add(new EventDay(calendar, DrawableUtils.getBlueCircleDrawableWithText(getContext(), "" + winCount)));        } else if ((winCount == 0) && (lossCount > 0)) {            // 패배만 있다.            DeveloperManager.displayLog("[F]_CalendarFragment", "[checkEventDayType] >> 기준 날짜로 Red 로 설정합니다. >>");            // List<EventDay> : 위 의 calendar 으로 EventDay 생성하여 추가 - Blue & Red            eventDayList.add(new EventDay(calendar, DrawableUtils.getRedCircleDrawableWithText(getContext(), "" + lossCount)));        } else {            DeveloperManager.displayLog("[F]_CalendarFragment", "[checkEventDayType] >> 승리도 패배도 없는 날인데요. >>");        } // [check 2]    }    /*                                      그 전 method     * =============================================================================================     * =============================================================================================     * */    /**     * [method] date 값을 billiardDataArrayList 의 getDate 값과 비교 하여 같으면 true , 다르면 true 반환     */    private boolean checkWhetherSameDate(String date) {        // cycle : billiardDataArrayList 의 size 만큼 순환하며 비교        for (int position = 0; position < billiardDataArrayList.size(); position++) {            DeveloperManager.displayLog("[F]_CalendarFragment", "[checkWhetherSameDate] getDate : " + date + " / getDate : " + billiardDataArrayList.get(position).getDate());            // [check 1] : billiardDate 의 getDate 와 클릭한 date 가 같다.            if (date.equals(billiardDataArrayList.get(position).getDate())) {                DeveloperManager.displayLog("[F]_CalendarFragment", "[checkWhetherSameDate] getDate 와 date 가 일치하는 곳이 있군요.");                return true;            } else {                continue;            }        }        DeveloperManager.displayLog("[F]_CalendarFragment", "[checkWhetherSameDate] getDate 와 date 가 모두 다릅니다.");        return false;    } // End of method [checkWhetherSameDate]    /**     * [method]  userName 과 winner 를 비교하여 승리, 패배 구분하여 문자 형태로 반환한다.     *     * @param userName 나의 이름     * @param winner   게임의 승리자 이름     * @return 승리이면 'W', 패배이면 'L'을 반환한다.     */    private char checkWinOrLoss(String userName, String winner) {        DeveloperManager.displayLog("[F]_CalendarFragment", "[checkWinOrLoss] user name : " + userName + " / nextIndex 번째 winner : " + winner);        // [lv/c]classification : 승패 여부를 저장        char classification = ' ';        // check : 유저이름과 승리자가 같다. - 승리        if (userName.equals(winner)) {            classification = 'W';            DeveloperManager.displayLog("[F]_CalendarFragment", "[checkWinOrLoss] userName : " + userName + " 은 승리했습니다.");        } else {            // check : 유저이름과 승리자가 다르다. - 패배            classification = 'L';            DeveloperManager.displayLog("[F]_CalendarFragment", "[checkWinOrLoss] userName : " + userName + " 은 패배했습니다.");        }        return classification;    } // End of method [checkWinOrLoss]    /**     * [method] 승리, 패배 여부를 문자로 구분하여 DateChecker 의 winCount 또는 lossCount 에 +1 하기     */    private void addOneOfWinOrLoss(char classification, DateChecker dateChecker, int index) {        switch (classification) {            case 'W':                // winCount : +1 하기 - 기준은 index 번째 이므로                dateChecker.addOneToWinCount(index);                DeveloperManager.displayLog("[F]_CalendarFragment", "[addOneOfWinOrLoss] 승리(W)자이므로 기준 " + index + " 번째의 승리수를 +1 했습니다. / 결과 : " + dateChecker.getWinCountToIndex(index));                break;            case 'L':                // lossCount : +1 하기 - 기준은 index 번째 이므로                dateChecker.addOneToLossCount(index);                DeveloperManager.displayLog("[F]_CalendarFragment", "[addOneOfWinOrLoss] 패배(L)자이므로 기준 " + index + " 번째의 패배수를 +1 했습니다. / 결과 : " + dateChecker.getLossCountToIndex(index));                break;            default:                break;        }    }    /**     * [method] 클래스 멤버 변수를 이용하여 calendar view 의 EventDay 를 셋팅하기     * <p>     * 같은 날짜일 때 중복 된 승패를 표현하지 못 함.     */    private void setEventDayOfWinOrLoss() {        // check 2 : userData 내용이 있다.        if (userData != null) {            // check 3 : billiardDbManager 가 초기화 되었다.            if (billiardDbManager.isInitializedDB()) {                // check 4 : billiardDataArrayList 의 size 가 0 이 아니다.                if (billiardDataArrayList.size() != 0) {                    // cycle : billiardDataArrayList 를 size 만큼 돌면서 getDate 값을 확인                    for (int position = 0; position < billiardDataArrayList.size(); position++) {                        // tokenizer : billiardData 의 date 를 year, month, day 로 구분한 배열 - [0]:year, [1]:month, [2]:day                        int[] dateTokenList = changeDateToIntArrayType(billiardDataArrayList.get(position).getDate());                        // check 5-1 : 나는 승리했나? 패배했나?                        char classification = checkWinOrLoss(userData.getName(), billiardDataArrayList.get(position).getWinner());                        // check 5-2 : 위 의 classification 값이 뭐임? - 'W':나의 승리, 'L':나의 패배                        switch (classification) {                            case 'W':                                // List<EventDay> : eventDayList 에 내용 추가 - EventDay 는 하나의 ArrayList 로 관리한다.                                DeveloperManager.displayLog("[F]_CalendarFragment", "[setEventDayToBilliardData] Win : [0]-" + dateTokenList[0] + " / [1]-" + dateTokenList[1] + " / [2]-" + dateTokenList[2]);                                Calendar calendarWin = Calendar.getInstance();                                calendarWin.set(dateTokenList[0], dateTokenList[1] - 1, dateTokenList[2]);                                eventDayList.add(new EventDay(calendarWin, DrawableUtils.getBlueCircleDrawableWithText(getContext(), "W")));                                continue;                            case 'L':                                // List<EventDay> : eventDayList 에 내용 추가 - EventDay 는 하나의 ArrayList 로 관리한다.                                DeveloperManager.displayLog("[F]_CalendarFragment", "[setEventDayToBilliardData] L : [0]-" + dateTokenList[0] + " / [1]-" + dateTokenList[1] + " / [2]-" + dateTokenList[2]);                                Calendar calendarLoss = Calendar.getInstance();                                calendarLoss.set(dateTokenList[0], dateTokenList[1] - 1, dateTokenList[2]);                                eventDayList.add(new EventDay(calendarLoss, DrawableUtils.getRedCircleDrawableWithText(getContext(), "L")));                                continue;                            default:                                // 'W'와 'L'이 아닌 값들은 billiardData 나 userData 에 이상한 값들이 있는 거야!                                break;                        } // End of check : switch                    } // End of cycle : for                    // CalendarView : 위 의 for 구문으로 구분된 EventDay 가 저장된 eventDayList 로 setting.                    calendarView.setEvents(eventDayList);                } else {                    DeveloperManager.displayLog("[F]_CalendarFragment", "[setEventDayToBilliardData] billiard 테이블에 저장된 내용이 없습니다.");                } // End of check 4            } else {                DeveloperManager.displayLog("[F]_CalendarFragment", "[setEventDayToBilliardData] billiardDbManager 가 초기화 되지 않았습니다. : " + billiardDbManager.isInitializedDB());            } // End of check 3        } else {            DeveloperManager.displayLog("[F]_CalendarFragment", "[setEventDayToBilliardData] user 테이블에 저장된 내용이 없습니다. ");        } // End of check 2    } // End of method    /**     * [method] date 를 year, month, day 로 구분하여 ArrayList<String> 으로 반환하기     */    private ArrayList<String> changeDateToStringArray(String date) {        /*         * ========================================================================================         * - 매개변수 형태 : "2020년 9월 30일"         * - 방식 : StringTokenizer , "년|월|일| "         *          (참고) '자바의 정석 1권' 514. StringTokenizer         * */        // ArrayList<String> : 분할 한 값 담을 객체 생성        ArrayList<String> dateTokenList = new ArrayList<>();        // StringTokenizer : dateTokenList 를 DATE_DELIMITER 으로 <delimiter:구분자>        StringTokenizer tokenizer = new StringTokenizer(date, DATE_DELIMITER);        // cycle : 구분된 값들이 있을 때까지 해당 값을 배열에 넣기        while (tokenizer.hasMoreTokens()) {            dateTokenList.add(tokenizer.nextToken());        }        return dateTokenList;    } // End of method}